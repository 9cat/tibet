; the singleton that powers a pair
; author: yakuhito

; modeled after https://github.com/Uniswap/v1-contracts/blob/master/contracts/uniswap_exchange.vy

(mod (
        PAIR_MOD_HASH ; sha256 of this module / puzzle (uncurried)
        SINGLETON_STRUCT  ; to quote did_innerpuz.clvm, 
            ;; 'my singleton_struct, formerly a Truth - ((SINGLETON_MOD_HASH, (LAUNCHER_ID, LAUNCHER_PUZZLE_HASH)))'
        P2_SINGLETON_MOD_HASH ; sha256tree of the p2_singleton module (uncurried)
        CAT_MOD_HASH ; sha256tree of the cat_v2 module (uncurried)
        LIQUIDITY_TAIL_MOD_HASH ; sha256 tree of the singleton delegated tail module (uncurried)

        TAIL_HASH ; identifies the token this pair holds
        FEE ; 0.3%

        LIQUIDITY ; holds the total number of liquidity tokens in existence
        XCH_RESERVE ; 'contract balance' of XCH
        TOKEN_RESERVE ; 'contract balance' of tokens

        action ; action the user wants to take
            ;; 0 - add liquidity (money printer go brr)
            ;; 1 - remove liquidity (sorry to see you go!)
            ;; 2 - XCH to token (sell XCH, buy token)
            ;; 3 - token to XCH (buy XCH, sell token)
        params ; params for the called method
            ;; add liquidity: (token_amount to_puzzle_hash)
            ;; remove liquidity: (liquidity_tokens_amount)
            ;; xch to token: (xch_amount to_address)
            ;; token to xch: (token_amount to_address)
    )
    
    ; libs
    (include curry-and-treehash.clinc)

    ; function codes
    (defconstant ACTION_ADD_LIQUIDITY 0)
    (defconstant ACTION_REMOVE_LIQUIDITY 1)
    (defconstant ACTION_XCH_TO_TOKEN 2)
    (defconstant ACTION_TOKEN_TO_XCH 3)

    ; params
    ;; 0 - add liquidity
    (defun-inline add_liquidity_token_amount_from_params (params) (f params))
    (defun-inline add_liquidity_to_puzzle_hash_from_params (params) (f (r params)))

    ; helper functions

    ; SINGLETON_STRUCT
    (defun-inline singleton_mod_hash_from_struct (singleton_struct) (f singleton_struct))
    (defun-inline singleton_launcher_from_struct (singleton_struct) (f (r singleton_struct)))
    (defun-inline singleton_launcher_puzzle_hash_from_struct (singleton_struct) (f (r (r singleton_struct))))

    ;; liquidity-related converters
    (defun-inline xch_amount_from_token_amount (token_amount)
        (+ (logior (/ (* token_amount XCH_SUPPLY) TOKEN_SUPPLY) 1) 1); make sure it's even
    )

    (defun-inline liquidity_minted_from_token_amount (token_amount)
        (- (logior (/ (* token_amount LIQUIDITY) TOKEN_SUPPLY) 1) 1) ; make sure it's even
    )

    ;; deposit-related
    (defun-inline p2_singleton_puzzle_hash (SINGLETON_STRUCT)
        (curry_hashes_inline P2_SINGLETON_MOD_HASH
            (singleton_mod_hash_from_struct SINGLETON_STRUCT)
            (singleton_launcher_from_struct SINGLETON_STRUCT)
            (singleton_launcher_puzzle_hash_from_struct SINGLETON_STRUCT)
        )
    )

    (defun-inline deposit_coins_condition (amount)
        (list
            CREATE_COIN
            (p2_singleton_puzzle_hash SINGLETON_STRUCT)
            amount    
        )
    )

    (defun-inline cat_puzzle_hash (tail_hash inner_puzzle_hash)
        (puzzle-hash-of-curried-function CAT_MOD_HASH
            ; parameters are given in reverse order
            inner_puzzle_hash
            (sha256tree tail_hash) ; hash of TAIL_PROGRAM_HASH
            (sha256tree CAT_MOD_HASH) ; another hash of hash
        )
    )

    (defun-inline create_token_condition (tail_hash inner_puzzle_hash amount)
        (list
            CREATE_COIN
            (cat_puzzle_hash tail_hash inner_puzzle_hash)
            amount    
        )
    )

    (defun-inline deposit_tokens_condition (amount)
        (create_token_condition TAIL_HASH (p2_singleton_puzzle_hash SINGLETON_STRUCT) amount)
    )

    (defun-inline mint_liquidity_condition (amount to_puzzle_hash)
        (create_token_condition
            ; todo: might have to invert SINGLETON_STRUCT
            ; ----------------------------------------------------------------------------------------------------
            (puzzle-hash-of-curried-function LIQUIDITY_TAIL_MOD_HASH SINGLETON_STRUCT)
            to_puzzle_hash
            amount
        )
    )

    (defun-inline create_liquidity_creation_condition (amount to_puzzle_hash)
        (list
            CREATE_COIN_ANNOUNCEMENT
            ; program in this case: (list CREATE_COIN to_puzzle_hash amount)
            ; no solution needed: ()
            (sha256tree (list CREATE_COIN to_puzzle_hash amount) ())
        )
    )

    ;; self-propagation

    (defun-inline recreate_self_condition (new_liquidity new_xch_reserve new_token_reserve)
        (list
            CREATE_COIN
            (puzzle-hash-of-curried-function PAIR_MOD_HASH
                ; TODO: review these parameters and their order
                new_token_reserve
                new_xch_reserve
                new_liquidity
                FEE
                TAIL_HASH
                LIQUIDITY_TAIL_MOD_HASH
                CAT_MOD_HASH
                P2_SINGLETON_MOD_HASH
                SINGLETON_STRUCT
                PAIR_MOD_HASH
            )
            1
        )
    )

    ; begin main methods

    (defun-inline add_liquidity (token_amount to_puzzle_hash) 
        (if (> liquidity 0)
            (list
                ; ensure deposit - XCH
                (deposit_coins_condition (xch_amount_from_token_amount token_amount)) ; TODO: MIGHT BE ODD

                ; ensure deposit - tokens
                (deposit_tokens_condition token_amount) ; TODO: MIGHT BE ODD

                ; mint liquidity tokens
                (mint_liquidity_condition (liquidity_minted_from_token_amount token_amount) to_puzzle_hash) ; TODO: MIGHT BE ODD
                (create_liquidity_creation_condition (liquidity_minted_from_token_amount token_amount) to_puzzle_hash)

                ; recreate
                (recreate_self_condition
                    (+ LIQUIDITY (liquidity_minted_from_token_amount token_amount))
                    (+ XCH_RESERVE (xch_amount_from_token_amount token_amount))
                    (+ TOKEN_RESERVE token_amount)
                )
            )
            ; else liquidity <= 0
            (x)
        )
    )

    ; main
    (if (= action ACTION_ADD_LIQUIDITY)
        (add_liquidity
            (add_liquidity_token_amount_from_params params)
            (add_liquidity_to_puzzle_hash_from_params params)
        )
        ; else
        (if (= action ACTION_REMOVE_LIQUIDITY)
            () ; remove liquidity
            ; else
            (if (= action ACTION_XCH_TO_TOKEN)
                () ; XCH to token
                ; else
                (if = action ACTION_TOKEN_TO_XCH)
                    () ; token to XCH
                    ; else
                    () ; merge coins
            )
        )
    )
)

; NOTES FOR FUTURE SELF
; reserves should only have 1 coin each
; what happens when minted liquidity / coin amounts are odd? please watch out
; puzzle-hash-of-curried-function is deprecated according to currey-and-treehash.clinc? ask on Keybase
; DO NOT REMOVE UNTIL CODE IS FINISHED: test all CREATE_COINs; make sure they are even